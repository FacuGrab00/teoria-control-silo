# Proyecto ESP-IDF

## √çndice
- [Librer√≠as](#Librer√≠as)
- [Uso de sensores](#uso-de-sensores)
- [Funciones clave](#funciones-clave)

## Librer√≠as

## `#include <stdio.h>`

Librer√≠a est√°ndar del lenguaje C. Se utiliza para funciones de entrada/salida, especialmente para debugging o impresi√≥n por consola.

- `printf()`: imprime texto formateado.
- `snprintf()`: escribe texto formateado en un buffer.

---

## `#include "freertos/FreeRTOS.h"`

Incluye definiciones centrales del sistema operativo en tiempo real **FreeRTOS**, que utiliza el ESP32 para manejar tareas concurrentes.

---

## `#include "freertos/task.h"`

Proporciona funciones para la creaci√≥n y gesti√≥n de tareas (threads livianos) bajo FreeRTOS.

- `xTaskCreate()`: crea tareas.
- `vTaskDelay()`: suspende la ejecuci√≥n de una tarea por un periodo dado.

---

## `#include "driver/gpio.h"`

Permite controlar los **pines GPIO** del ESP32.

- `gpio_set_direction()`: configura el modo (entrada/salida) de un pin.
- `gpio_set_level()`: establece el estado de un pin de salida.
- `gpio_get_level()`: lee el estado de un pin de entrada.

Usado para sensores como el **HC-SR04** y el control de se√±ales digitales.

---

## `#include "esp_log.h"`

M√≥dulo de logging integrado del ESP-IDF.

- `ESP_LOGI()`, `ESP_LOGE()`: permiten imprimir mensajes con etiquetas y niveles (INFO, ERROR, etc).
- Muy √∫til para depuraci√≥n.

---

## `#include "esp_timer.h"`

Proporciona acceso a **temporizadores de alta resoluci√≥n** (microsegundos).

- `esp_timer_get_time()`: devuelve el tiempo actual en microsegundos desde que se inici√≥ el sistema.
- Usado para medir tiempos de respuesta precisos, por ejemplo para calcular distancia con HC-SR04.

---

## `#include "esp_rom_sys.h"`

Incluye funciones de utilidad implementadas en la **ROM del chip ESP32**.

- `esp_rom_delay_us()`: pausa la ejecuci√≥n por un n√∫mero dado de microsegundos.
- √ötil para generar delays muy precisos sin temporizadores externos.

---

## `#include "dht.h"`

Librer√≠a externa que permite leer sensores **DHT22** (temperatura y humedad).

- `dht_read_data()`: realiza la lectura de temperatura y humedad desde un pin GPIO.

---

## `#include "mqtt_client.h"`

Librer√≠a oficial del ESP-IDF para conectarse a brokers MQTT (como Mosquitto en Raspberry Pi).

- `esp_mqtt_client_init()`: inicializa el cliente MQTT.
- `esp_mqtt_client_publish()`: env√≠a mensajes a un t√≥pico.
- `esp_mqtt_client_start()`: inicia la conexi√≥n al broker.

---

## `#include "nvs_flash.h"`

Permite usar la **memoria flash no vol√°til (NVS)** para guardar datos entre reinicios (ej: configuraci√≥n WiFi).

- `nvs_flash_init()`: inicializa el sistema de almacenamiento no vol√°til.
- Requerido para el stack WiFi y otras funcionalidades persistentes.

---

## `#include "esp_wifi.h"`

Proporciona todas las funciones necesarias para la **conexi√≥n WiFi** del ESP32 en modo estaci√≥n (STA).

- `esp_wifi_init()`, `esp_wifi_start()`, `esp_wifi_connect()`.

---

## `#include "esp_event.h"`

Sistema de eventos del ESP-IDF. Necesario para manejar eventos asincr√≥nicos del WiFi o MQTT.

- `esp_event_loop_create_default()`: inicializa el loop de eventos.
- Se utiliza junto con WiFi y MQTT para registrar manejadores de eventos.

---

## `#include "esp_netif.h"`

Inicializa y configura la interfaz de red del ESP32 (ya sea WiFi o Ethernet).

- `esp_netif_create_default_wifi_sta()`: configura el dispositivo como cliente WiFi (station).

---

üîß Todas estas librer√≠as forman parte del entorno de desarrollo **ESP-IDF** y son necesarias para implementar sensores f√≠sicos, conexi√≥n WiFi y comunicaci√≥n MQTT.


## Uso de sensores

# Sensor DHT22 (AM2302) - Funcionamiento

El **DHT22** es un sensor digital que mide **temperatura** y **humedad relativa**. Utiliza un protocolo de comunicaci√≥n de un solo hilo (1-wire propietario) para enviar los datos al microcontrolador.

---

## ¬øQu√© mide?

- **Temperatura ambiente** (¬∞C)
- **Humedad relativa** (%)

---

## Pines del sensor

1. **VCC**: Alimentaci√≥n (3.3V o 5V)
2. **DATA**: Comunicaci√≥n de datos
3. **NC**: No conectado (puede no estar presente)
4. **GND**: Tierra

---

## Comunicaci√≥n - Paso a paso

### 1. Se√±al de inicio (Start Signal)

El microcontrolador:

- Configura el pin como salida.
- Baja el pin a nivel **bajo** durante al menos **1 ms**.
- Luego lo sube a nivel **alto** por unos **20-40 ¬µs**.
- Cambia el pin a modo **entrada** para escuchar la respuesta.

### 2. Respuesta del sensor

El DHT22 responde con:

- 80 ¬µs a nivel **bajo**
- 80 ¬µs a nivel **alto**

Esto indica que el sensor est√° listo para enviar datos.

### 3. Env√≠o de datos

Se env√≠an **40 bits** (5 bytes):

| Byte | Descripci√≥n                      |
|------|----------------------------------|
| 1    | Parte alta de humedad            |
| 2    | Parte baja de humedad            |
| 3    | Parte alta de temperatura        |
| 4    | Parte baja de temperatura        |
| 5    | Checksum (suma de los 4 anteriores)

### 4. Codificaci√≥n de bits

Cada bit se transmite as√≠:

- Pulso bajo fijo de **~50 ¬µs**
- Luego:
  - Pulso alto de **26-28 ¬µs** = bit **0**
  - Pulso alto de **~70 ¬µs** = bit **1**

### 5. C√°lculo final

- La humedad y temperatura se calculan combinando los dos bytes correspondientes.
- Si el bit 15 de temperatura est√° en 1, el valor es negativo.
- El checksum se usa para verificar integridad.

---

## Notas

- Intervalo recomendado de lectura: **cada 2 segundos**
- No se debe leer el sensor muy seguido, puede dar datos inv√°lidos
- Sensor relativamente lento pero preciso

---

## Resumen visual

```plaintext
MCU inicia --> Nivel bajo (1ms) --> Nivel alto (30¬µs) --> Escucha
DHT responde: 80¬µs bajo + 80¬µs alto
Luego transmite 40 bits codificados por duraci√≥n del pulso alto
```

---

## Caracter√≠sticas t√©cnicas

- Rango de humedad: 0‚Äì100% RH, ¬±2‚Äì5% precisi√≥n
- Rango de temperatura: -40 a +80 ¬∞C, ¬±0.5 ¬∞C precisi√≥n
- Frecuencia de muestreo: 0.5 Hz (cada 2 segundos)


## üß≠ ¬øQu√© es el HC-SR04?

El **HC-SR04** es un sensor ultras√≥nico que mide la distancia entre √©l y un objeto usando **ondas de sonido de alta frecuencia (ultrasonido)**. Es muy usado en rob√≥tica, IoT y automatizaci√≥n.

---

## ‚öôÔ∏è ¬øC√≥mo funciona?

1. **Emisi√≥n del pulso ultras√≥nico**  
   El sensor tiene un pin llamado **Trigger**. Cuando recibe un pulso el√©ctrico de al menos **10 microsegundos**, el sensor emite una **se√±al ultras√≥nica** (a unos 40 kHz) hacia adelante.

2. **Rebote del sonido**  
   Esa se√±al viaja por el aire, **rebota en un objeto** y vuelve al sensor.

3. **Recepci√≥n del eco (controlada por el sensor)**  
   El sensor tiene un segundo pin, llamado **Echo**.  
   - **Este pin es gestionado autom√°ticamente por el sensor**, no por el microcontrolador.
   - El pin **Echo se pone en alto** despu√©s de que el sensor emite el ultrasonido, para indicar que est√° esperando el eco.
   - Cuando el eco regresa, el sensor **pone el pin Echo en bajo**.  
   - El tiempo que el pin permanece en alto representa el viaje de ida y vuelta del sonido.

4. **Medici√≥n del tiempo**  
   El tiempo que el pin Echo permanece en alto corresponde al **tiempo que tard√≥ el ultrasonido en ir y volver**.

5. **C√°lculo de distancia**  
   Como el sonido viaja a una velocidad conocida (~343 m/s o ~29.1 Œºs/cm), se puede usar esta f√≥rmula:

   ```
   Distancia (cm) = Tiempo de eco (Œºs) / (2 √ó 29.1)
   ```

   - Se divide por 2 porque el tiempo incluye ida y vuelta.
   - 29.1 Œºs/cm es el tiempo que tarda el sonido en recorrer un cent√≠metro en el aire.

---

## üìå Ejemplo

Si el tiempo medido es 1164 microsegundos:

```
Distancia = 1164 / (2 √ó 29.1) ‚âà 20 cm
```

---

## üßæ Resumen visual

| Paso        | Acci√≥n                                                |
|-------------|--------------------------------------------------------|
| 1. Trigger  | Se env√≠a un pulso de 10 Œºs                             |
| 2. Emisi√≥n  | El sensor emite un ultrasonido                         |
| 3. Rebote   | El sonido rebota en un objeto                          |
| 4. Echo     | El pin Echo se mantiene alto hasta recibir el eco     |
| 5. Medici√≥n | Se mide el tiempo en microsegundos                     |
| 6. C√°lculo  | Se calcula la distancia usando una f√≥rmula             |


## Funciones clave

# üìè Funci√≥n `obtener_distancia_hcsr04()`

Esta funci√≥n mide la distancia desde el sensor HC-SR04 hasta un objeto frente a √©l, usando temporizaci√≥n precisa de los pulsos ultras√≥nicos.

---

## üîß Paso a paso del funcionamiento

### 1. **Configurar los pines GPIO**

```c
gpio_set_direction(TRIGGER_GPIO, GPIO_MODE_OUTPUT);
gpio_set_direction(ECHO_GPIO, GPIO_MODE_INPUT);
```

- El pin **Trigger** se configura como salida.
- El pin **Echo** se configura como entrada.
- Esto permite **emitir un pulso ultras√≥nico** y luego **escuchar el eco** desde el sensor.

---

### 2. **Enviar el pulso de activaci√≥n**

```c
gpio_set_level(TRIGGER_GPIO, 1);
esp_rom_delay_us(10);
gpio_set_level(TRIGGER_GPIO, 0);
```

- Se pone el pin Trigger en **alto durante 10 Œºs**, que es el requisito m√≠nimo del HC-SR04 para iniciar una medici√≥n.
- Despu√©s se baja el pin, completando el pulso.
- Este pulso hace que el sensor emita una **r√°faga ultras√≥nica de 8 ciclos a 40 kHz**.
- A partir de aqu√≠, el sensor comienza a manejar el pin `Echo`.

---

### 3. **Esperar que el pin Echo se ponga en alto**

```c
int64_t tiempo_inicio = esp_timer_get_time();
while(gpio_get_level(ECHO_GPIO) == 0) {
    if (esp_timer_get_time() - tiempo_inicio > 5000) {
        ESP_LOGE(TAG, "Timeout esperando el pin echo en alto");
        return -1.0;
    }
}
```

- Esta secci√≥n **espera que el sensor active el pin `Echo`**, lo que indica que ha comenzado la escucha del eco.
- Si despu√©s de 5 milisegundos (`5000 Œºs`) el pin sigue en bajo, algo fall√≥:
  - El sensor **no recibi√≥ el pulso Trigger**.
  - El sensor **est√° da√±ado o mal conectado**.
  - El pin Echo **no est√° configurado correctamente**.
- Se considera un error cr√≠tico de inicio de medici√≥n y se retorna `-1.0`.


---

### 4. **Medir cu√°nto tiempo permanece en alto el pin Echo**

```c
int64_t tiempo_inicio_medicion = esp_timer_get_time();
while(gpio_get_level(ECHO_GPIO) == 1) {
    if (esp_timer_get_time() - tiempo_inicio_medicion > 60000) {
        ESP_LOGE(TAG, "Timeout esperando el pin echo en bajo");
        return -1.0;
    }
}
int64_t duracion = esp_timer_get_time() - tiempo_inicio_medicion;
```

- Una vez que `Echo` se pone en alto, **empieza la medici√≥n del tiempo**.
- El pin se mantiene alto **hasta que el eco del ultrasonido regresa al sensor**.
- Si el pin permanece en alto m√°s de 60 ms:
  - Es probable que el **eco no haya sido detectado** (objeto fuera de alcance).
  - Se evita un bloqueo del sistema y se retorna `-1.0`.
- Si todo funciona bien, se mide la duraci√≥n del pulso `Echo`, que representa el **tiempo de ida y vuelta del sonido**.

---

### 5. **Calcular la distancia**

```c
float distancia = (duracion / 2.0) / 29.1;
```

- Se divide por 2 para obtener **solo el tiempo de ida**.
- Luego se divide por 29.1, ya que **el sonido recorre 1 cm cada 29.1 Œºs en el aire**.
- Esto convierte el tiempo en microsegundos a una distancia en **cent√≠metros**.

---

### 6. **Retornar la distancia**

```c
return distancia;
```

- Si no hubo errores, se devuelve la **distancia medida**.
- Si se produjo alg√∫n timeout, la funci√≥n ya habr√° retornado `-1.0` antes.

---

## üß† ¬øPor qu√© se hace as√≠?

- Se utilizan **delays precisos** con `esp_rom_delay_us()` para controlar el pulso de activaci√≥n.
- Se mide el tiempo en **microsegundos** con `esp_timer_get_time()` para obtener resultados exactos.
- Se implementan **timeouts** para evitar bloqueos si el sensor falla o no detecta nada.


### ‚úÖ Requisito del sensor

Seg√∫n el fabricante:

> *‚ÄúYou need to supply a minimum 10‚ÄØŒºs high-level pulse to the Trigger input to start the ranging.‚Äù*

Esto significa que:

- El sensor necesita un pulso en alto (nivel HIGH) de **al menos 10 microsegundos** para empezar una medici√≥n.
- Si el pulso es m√°s corto, el sensor **lo ignora** y no emite ultrasonido.

### üß† ¬øQu√© hace el sensor durante ese pulso?

1. Espera a que el pulso se termine (cuando pasa de alto a bajo).
2. Entonces:
   - Introduce una peque√±a espera (~750 Œºs).
   - Emite el pulso ultras√≥nico.
   - Activa el pin **Echo** para comenzar la medici√≥n.

### üß™ ¬øQu√© pasa si el pulso dura m√°s?

- El sensor tambi√©n lo acepta.
- Pero **no comienza la medici√≥n hasta que el pulso termina** (flanco de bajada).

---

## üß† Notas t√©cnicas

| Par√°metro              | Valor      | Descripci√≥n                                    |
| ---------------------- | ---------- | ---------------------------------------------- |
| Pulso Trigger          | 10 Œºs      | Duraci√≥n m√≠nima para activar el sensor         |
| Timeout de espera HIGH | 5 ms       | Tiempo m√°ximo para que el pin `ECHO` se active |
| Timeout de espera LOW  | 60 ms      | Tiempo m√°ximo para recibir el eco              |
| Velocidad del sonido   | 29.1 Œºs/cm | Para calcular la distancia                     |

---

### üßæ En resumen

| Duraci√≥n del pulso Trigger | Resultado                        |
|----------------------------|-----------------------------------|
| < 10‚ÄØŒºs                    | ‚ùå Ignorado, no se mide           |
| = 10‚ÄØŒºs                    | ‚úÖ Ideal, inicia medici√≥n         |
| > 10‚ÄØŒºs                    | ‚úÖ Funciona, pero no es necesario |

